package oarlib.graph.io;

import gnu.trove.TIntObjectHashMap;
import oarlib.core.Graph;
import oarlib.core.Link;
import oarlib.core.Vertex;
import oarlib.exceptions.UnsupportedFormatException;
import oarlib.graph.impl.UndirectedGraph;
import oarlib.link.impl.Edge;
import oarlib.vertex.impl.UndirectedVertex;
import org.apache.log4j.Logger;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;

/**
 * Writer to output various file formats.  Plans to use Gephi for visualization.
 *
 * @author Oliver
 */
public class GraphWriter {

    private static final Logger LOGGER = Logger.getLogger(GraphWriter.class);

    private GraphFormat.Name mFormat;

    public GraphWriter(GraphFormat.Name format) {
        mFormat = format;
    }

    public GraphFormat.Name getFormat() {
        return mFormat;
    }

    public void setFormat(GraphFormat.Name newFormat) {
        mFormat = newFormat;
    }

    public boolean writeGraph(Graph<?, ?> g, String filename) throws UnsupportedFormatException {
        //TODO
        switch (mFormat) {
            case OARLib:
                return writeOarlibGraph(g, filename);
            case Campos:
                break;
            case Corberan:
                break;
            case DIMACS_Modified:
                break;
            case Simple:
                break;
            case Yaoyuenyong:
                break;
            case METIS:
                return writeMETISGraph(g, filename);
            default:
                break;
        }
        LOGGER.error("While the format seems to have been added to the Format.Name type list,"
                + " there doesn't seem to be an appropriate write method assigned to it.  Support is planned in the future," +
                "but not currently available");
        throw new UnsupportedFormatException();
    }

    private boolean writeMETISGraph(Graph<?, ?> g, String filename) {
        try {
            Vertex first, second;
            UndirectedGraph g2 = new UndirectedGraph(g.getVertices().size());
            Collection<? extends Vertex> gVertices = g.getVertices();
            TIntObjectHashMap<UndirectedVertex> g2Vertices = g2.getInternalVertexMap();

            if (g.getClass() == UndirectedGraph.class)
                g2 = (UndirectedGraph) g;
            else {
                for (Link<? extends Vertex> l : g.getEdges()) {
                    first = g2Vertices.get(l.getEndpoints().getFirst().getId());
                    second = g2Vertices.get(l.getEndpoints().getSecond().getId());
                    if (!first.getNeighbors().containsKey(second))
                        g2.addEdge(first.getId(), second.getId(), 1);
                }
                for (Vertex v : gVertices) {
                    g2Vertices.get(v.getId()).setCost(v.getCost());
                }
            }

            PrintWriter pw = new PrintWriter(filename, "UTF-8");
            pw.println("% This is a METIS file generated by the Open Source, Arc-Routing Library (OAR Lib).");
            pw.println("% For more information on the METIS Library, or the format please visit: ");
            pw.println("% http://glaros.dtc.umn.edu/gkhome/metis/metis/overview");
            pw.println("%");
            pw.println("%");

            //the header
            int n = g.getVertices().size();
            int m = g2.getEdges().size();
            String header = "";
            header = header + n + " " + m + " " + "011" + " 1";
            pw.println(header);

            TIntObjectHashMap<UndirectedVertex> indexedVertices = g2.getInternalVertexMap();
            UndirectedVertex temp;
            HashMap<UndirectedVertex, ArrayList<Edge>> tempNeighbors;
            boolean shownWarning = false;
            for (int i = 1; i <= n; i++) {
                String line = "";
                temp = indexedVertices.get(i);

                line += temp.getCost() + " ";
                tempNeighbors = temp.getNeighbors();
                for (UndirectedVertex neighbor : tempNeighbors.keySet()) {
                    line += neighbor.getId() + " ";
                    line += tempNeighbors.get(neighbor).get(0).getCost() + " ";
                    if (tempNeighbors.get(neighbor).size() > 1 && !shownWarning) {
                        System.out.println("Multigraphs are not currently supported; we shall only use one of the edges connecting these vertices.");
                        shownWarning = true;
                    }
                }
                pw.println(line);
            }

            pw.close();
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    private boolean writeOarlibGraph(Graph<?, ?> g, String filename) {
        return false;
    }

}
