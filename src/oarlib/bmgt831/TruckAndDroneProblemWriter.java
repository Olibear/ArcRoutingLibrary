/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2015 Oliver Lum
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package oarlib.bmgt831;

import oarlib.display.GraphDisplay;
import oarlib.graph.graphgen.OSM_Fetcher;
import oarlib.graph.graphgen.Util.BoundingBox;
import oarlib.graph.graphgen.Util.OSM_BoundingBoxes;
import oarlib.graph.impl.UndirectedGraph;
import oarlib.graph.impl.WindyGraph;
import oarlib.graph.util.Utils;
import oarlib.link.impl.Edge;
import oarlib.link.impl.WindyEdge;
import oarlib.vertex.impl.UndirectedVertex;
import oarlib.vertex.impl.WindyVertex;

import java.io.PrintWriter;

/**
 * Because this is a node routing problem, all of the associated classes are currently special-cased out.  Eventually
 * I would like to integrate this into the library so that it becomes a general routing problm library.
 * <p/>
 * Created by oliverlum on 3/26/15.
 */
public class TruckAndDroneProblemWriter {

    public static void writeTruckAndDroneProblem(String filePath) {
        writeTruckAndDroneProblem(filePath, 1000);
    }

    public static void writeTruckAndDroneProblem(String filePath, long seed) {

        //generate the underlying street network
        int n = 20;
        int maxCost = 10;
        int droneFlightDuration = 500;
        int fleetSize = 20;
        double alpha = .85;
        int dronesPerVehicle = 6;
        int truckCapacity = 120;

        /*UndirectedRectangularGraphGenerator urgg = new UndirectedRectangularGraphGenerator(seed);
        UndirectedGraph network = urgg.generateGraph(n,maxCost,0,true);

        //now eliminate 10% of the links
        Random rng = new Random(seed);
        int m = network.getEdges().size();

        try {
            for (int i = 1; i <= m; i++) {
                if (rng.nextDouble() < .3) {
                    Edge e = network.getEdge(i);
                    network.removeEdge(e);
                    if (!CommonAlgorithms.isConnected(network))
                        network.addEdge(e);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return;
        }*/


        try {
            UndirectedGraph network = new UndirectedGraph();
            WindyGraph streetNetwork;
            for (BoundingBox bb : OSM_BoundingBoxes.CITY_INSTANCES) {
                OSM_Fetcher fetcher = new OSM_Fetcher(bb);
                streetNetwork = fetcher.queryForGraph();
                int n2 = streetNetwork.getVertices().size();
                for (int i = 1; i <= n2; i++) {
                    WindyVertex wv = streetNetwork.getVertex(i);
                    UndirectedVertex toAdd = new UndirectedVertex("");
                    toAdd.setCoordinates(wv.getX(), wv.getY());
                    network.addVertex(toAdd);
                }
                for (WindyEdge we : streetNetwork.getEdges())
                    network.addEdge(we.getFirstEndpointId(), we.getSecondEndpointId(), we.getCost(), false);


                //now actually write

                //front matter
                PrintWriter pw = new PrintWriter(filePath, "UTF-8");
                pw.println("%");
                pw.println("% This is a file generated by the Open Source, Arc-Routing Library (OAR Lib).");
                pw.println("% For more information on OAR Lib, or the format please visit: ");
                pw.println("% https://github.com/Olibear/ArcRoutingLibrary ");
                pw.println("%");

                //the header
                pw.println();
                pw.println("================================");
                pw.println("Format: OAR Lib");
                pw.println("Graph Type:UNDIRECTED");
                pw.println("Problem Type:TRUCK_AND_DRONE");
                pw.println("Fleet Size (k):" + fleetSize);
                pw.println("Number of Depots:SINGLE_DEPOT");
                pw.println("Alpha:" + alpha);
                pw.println("Drones Per Vehicle (l):" + dronesPerVehicle);
                pw.println("Drone Flight Duration (t_drone):" + droneFlightDuration);
                pw.println("Truck Capacity (cap_truck):" + truckCapacity);

                network.setDepotId(Utils.findCenterVertex(network));
                String depotIDString = "Depot ID(s) (d):" + network.getDepotId();

                pw.println(depotIDString);
                pw.println("N:" + network.getVertices().size());
                pw.println("M:" + network.getEdges().size());
                pw.println("================================");


                //Formatting details
                pw.println();
                pw.println("LINKS");

                String lineFormat = "Line Format:V1,V2,COST";
                lineFormat += ",REQUIRED";

                pw.println(lineFormat);

                //edges
                String line;
                for (Edge e : network.getEdges()) {
                    line = "";
                    line += e.getEndpoints().getFirst().getId() + ","
                            + e.getEndpoints().getSecond().getId() + ","
                            + e.getCost();
                    line += "," + e.isRequired();
                    pw.println(line);
                }

                pw.println("===========END LINKS============");

                boolean hasVertexCoords = false;
                for (UndirectedVertex v : network.getVertices())
                    if (v.hasCoordinates()) {
                        hasVertexCoords = true;
                        break;
                    }

                if (hasVertexCoords) {
                    pw.println();
                    pw.println("VERTICES");

                    lineFormat = "Line Format:x,y";
                    pw.println(lineFormat);

                    //vertices
                    n = network.getVertices().size();
                    for (int i = 1; i <= n; i++) {
                        UndirectedVertex v = network.getVertex(i);
                        line = v.getX() + "," + v.getY();
                        pw.println(line);
                    }
                    pw.println("===========END VERTICES============");
                }

                //Visualize
                GraphDisplay gd = new GraphDisplay(GraphDisplay.Layout.YifanHu, network, "truckAndDrone_Real1");
                gd.export(GraphDisplay.ExportType.PDF);

                pw.close();
                break;
            }


        } catch (Exception e) {
            e.printStackTrace();
            return;
        }

    }
}
